<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="阿巴">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/07/16/服务器请求伪造（ssrf）漏洞/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="[toc] 服务器端请求伪造漏洞一.漏洞介绍SSRF (Server-Side Request Forgery,服务器端请求伪造)是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统)。 漏洞成因 在某些情况下，服务端的服务程序需要其他服务端的数据，假如服务器没">
<meta property="og:type" content="article">
<meta property="og:title" content="服务器端请求伪造漏洞">
<meta property="og:url" content="http://example.com/2023/07/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF%EF%BC%89%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="阿巴">
<meta property="og:description" content="[toc] 服务器端请求伪造漏洞一.漏洞介绍SSRF (Server-Side Request Forgery,服务器端请求伪造)是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统)。 漏洞成因 在某些情况下，服务端的服务程序需要其他服务端的数据，假如服务器没">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF%EF%BC%89%E6%BC%8F%E6%B4%9E/fastCGI.png">
<meta property="article:published_time" content="2023-07-16T06:35:17.000Z">
<meta property="article:modified_time" content="2023-08-02T12:42:25.798Z">
<meta property="article:author" content="阿巴">
<meta property="article:tag" content="web安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF%EF%BC%89%E6%BC%8F%E6%B4%9E/fastCGI.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/8d.png@1256w_1256h_!web-article-pic.webp" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/8d.png@1256w_1256h_!web-article-pic.webp">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/8d.png@1256w_1256h_!web-article-pic.webp">
    <!--- Page Info-->
    
    <title>
        
            服务器端请求伪造漏洞 -
        
        阿巴
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/e6d1c777bb54674dd5cc6ed2c6147596a899ed7b.jpg@1256w_708h_!web-article-pic.webp","dark":"/images/688bff5fab134b2da7d52ca53163372d39812ec8.jpg@1256w_708h_!web-article-pic.webp"},"title":"阿巴的小站","subtitle":{"text":[],"hitokoto":{"enable":true,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/621779","instagram":"https://www.instagram.com/","zhihu":"https://www.zhihu.com/people/zhi-chu-85-7","twitter":null,"email":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.2","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"如果讨厌当前的处境，那就不惜一切代价上去，然后去追随梦想吧！","links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/12/11  12：00：00"};
    Global.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                阿巴
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                
                  <h1 class="article-title-regular">服务器端请求伪造漏洞</h1>
                
              </div>
              
                     
            
            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/49871906.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">阿巴</span>
                            
                                <span class="author-label">Lv2</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-07-16 14:35:17</span>
        <span class="mobile">2023-07-16 14:35:17</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-08-02 20:42:25</span>
            <span class="mobile">2023-08-02 20:42:25</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <span id="more"></span>

<p>[toc]</p>
<h1 id="服务器端请求伪造漏洞"><a href="#服务器端请求伪造漏洞" class="headerlink" title="服务器端请求伪造漏洞"></a>服务器端请求伪造漏洞</h1><h2 id="一-漏洞介绍"><a href="#一-漏洞介绍" class="headerlink" title="一.漏洞介绍"></a>一.漏洞介绍</h2><p>SSRF (Server-Side Request Forgery,服务器端请求伪造)是一种由攻击者构造请求，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统(正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统)。</p>
<p><strong>漏洞成因</strong></p>
<p>在某些情况下，服务端的服务程序需要其他服务端的数据，假如服务器没有对其请求的目标地址做过滤和限制，导致黑客可以利用此缺陷请求任意服务器资源，其中就包含隐匿在内网的应用。</p>
<p><strong>出现地点</strong></p>
<ul>
<li>服务器主动发起网络请求，例如HTTP／HTTPS／Socket</li>
<li>分享功能，通过URL分享网页内容，<a class="link"   href="https://link.zhihu.com/?target=http://www.360bug.net/index.php/archives/49/?from=timeline&isappinstalled=0" >微博SSRF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>图片加载、下载功能</li>
<li>邮件系统</li>
<li>api远程调用</li>
<li>只要是服务器可以主动发起网络请求便可能出现</li>
</ul>
<p><strong>漏洞危害</strong></p>
<ol>
<li>对目标服务器所在的内网进行IP存活性扫描和端口扫描</li>
<li>利用扫描的指纹信息判断开放的服务，从而对内网的主机进行攻击</li>
<li>识别内网WEB应用指纹，判断应用类型进行攻击</li>
<li>使用特定协议攻击应用（gopher、dict、file、FTP／SFTP等）</li>
</ol>
<h2 id="二-漏洞分类"><a href="#二-漏洞分类" class="headerlink" title="二.漏洞分类"></a>二.漏洞分类</h2><h3 id="1-跨站请求伪造（CSRF）"><a href="#1-跨站请求伪造（CSRF）" class="headerlink" title="1.跨站请求伪造（CSRF）"></a>1.跨站请求伪造（CSRF）</h3><p><strong>漏洞简介</strong></p>
<p>CSRF（Cross-Site Request Forgery）跨站请求伪造，又称为“One-Click Attack”或“Session Riding”，是一种常见的Web应用程序安全漏洞。它利用用户在受攻击网站的有效会话中的身份进行攻击，通过诱导用户在另一个网站上执行恶意操作，执行伪造请求来欺骗并利用目标网站的功能。</p>
<p><strong>攻击原理</strong></p>
<p>用户在正常使用账号密码登录a网站之后，a网站回返回一个cookie给用户，用户在没有登出a网站时，访问了b网站（由黑客构造），</p>
<p>b网站在收到用户请求之后，返回攻击语句，构造访问a网站的语句，浏览器在收到攻击语句之后，携带着a网站返回给用户的cookie访问a网站，a网站如果缺少检测，就会以用户的权限处理b网站的操作。</p>
<p><strong>漏洞判断</strong></p>
<ol>
<li>抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞</li>
<li>如果有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</li>
<li>利用工具进行CSRF检测。如：CSRFTESTER，CSRF REQUEST BUILDER等</li>
</ol>
<p><strong>漏洞分类</strong></p>
<ul>
<li><p>get型：假设一个网站可以通过get请求来修改用户的邮箱，如：http:&#x2F;&#x2F;***&#x2F;user.php?id&#x3D;1&amp;email&#x3D;<a class="link"   href="mailto:&#49;&#x32;&#51;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;" >&#49;&#x32;&#51;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ,j假设这个请求的的意义为将用户id为一的用户的邮箱改为<a class="link"   href="mailto:&#50;&#51;&#52;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d;" >&#50;&#51;&#52;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>得话，我们便可以构造链接将<a class="link"   href="mailto:&#49;&#x32;&#x33;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;" >&#49;&#x32;&#x33;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>改为<a class="link"   href="mailto:&#97;&#x62;&#x63;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;" >&#97;&#x62;&#x63;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。再引诱户点击此链接，用户的邮箱便可能被改为我们所指定的邮箱。</p>
</li>
<li><p>post型：在普通用户的眼中，点击网页-&gt;打开试看视频-&gt;购买视频是一个很正常的一个流程。可是在攻击者的眼中可以算正常，但又不正常的，当然不正常的情况下，是在开发者安全意识不足所造成的。攻击者在购买处抓到购买时候网站处理购买(扣除)用户余额的地址。比如：&#x2F;coures&#x2F;user&#x2F;handler&#x2F;25332&#x2F;buy.php 。通过提交表单，buy.php处理购买的信息，这里的25532为视频ID。那么攻击者现在构造一个链接，链接中包含以下内容</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&lt;form action=/coures/user/handler/25332/buy method=POST>
&lt;input type="text" name="xx" value="xx" />
&lt;/form>
&lt;script> document.forms[0].submit(); &lt;/script> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>当用户访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作，自动购买了id为25332的视频，从而导致受害者余额扣除</p>
</li>
</ul>
<h3 id="2-服务器端请求伪造-SSRF"><a href="#2-服务器端请求伪造-SSRF" class="headerlink" title="2.服务器端请求伪造(SSRF)"></a>2.服务器端请求伪造(SSRF)</h3><p><strong>漏洞简介</strong></p>
<p>SSRF（Server-Side Request Forgery）服务器端请求伪造是一种常见的Web应用程序安全漏洞。它允许攻击者在服务器端发起请求，绕过服务器的访问限制，访问服务器本地的资源或与内部网络通信</p>
<p><strong>攻击原理</strong></p>
<p>在一般情况下，用户无法直接访问内网，只能访问一个与外网连接的服务器，但当这个外部服务器存在ssrf漏洞时，我们便可以通过这个服务器，对内网进行访问。</p>
<p><strong>常用函数与协议</strong></p>
<ul>
<li><p>HTTP&#x2F;HTTPS协议：SSRF漏洞常用来利用服务器发起对内部或外部Web应用的HTTP&#x2F;HTTPS请求，对目标服务器进行攻击或者获取敏感信息。</p>
</li>
<li><p>file协议：攻击者可以通过此协议来访问系统中的文件内容</p>
</li>
<li><p>ftp协议：攻击者可以利用SSRF漏洞通过FTP协议访问内部系统中的敏感文件，如果FTP服务器开启了匿名访问，则可以直接获取敏感文件。</p>
</li>
<li><p>gopher协议：Gopher是一种早期的互联网协议，类似于HTTP协议，用于检索和浏览文档。攻击者可以利用Gopher协议来进行SSRF攻击，通过构造恶意的Gopher请求来访问内部系统的敏感信息或发起攻击。其中该协议的url格式如下：<code>gopher://host:port/path</code>，其中host是目标服务器的主机名或IP地址，port是Gopher服务的端口号（<strong>默认为70</strong>），path是要访问的资源路径。Gopher协议格式：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token constant">URL</span><span class="token punctuation">:</span>gopher<span class="token punctuation">:</span><span class="token comment">//&lt;host>:&lt;port>/&lt;gopher-path>_后接TCP数据流</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>gopher的默认端口是70</li>
<li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li>
</ul>
<p>关于此协议的用法详情见：<a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112055947" >Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>dict:&#x2F;&#x2F; 字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;&#x2F;ip:6739&#x2F;info：</p>
</li>
<li><p>sftp:&#x2F;&#x2F; SSH文件传输协议或安全文件传输协议</p>
</li>
<li><p>ldap:&#x2F;&#x2F; 轻量级目录访问协议</p>
</li>
<li><p>tftp:&#x2F;&#x2F; 简单文件传输协议</p>
</li>
</ul>
<p>具体介绍见：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43378996/article/details/124050308" >SSRF漏洞原理攻击与防御(超详细总结)_零点敲代码的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>漏洞检测</strong></p>
<ol>
<li>排除法：查看是否是在本地进行了请求比如： 请求链接为：<a class="link"   target="_blank" rel="noopener" href="http://www.xxx.com/a.php?image=%60http://www.baidu.com/img/logo.png%60,%E5%8F%B3%E9%94%AE%E6%96%B0%E7%AA%97%E5%8F%A3%E6%89%93%E5%BC%80%E5%9B%BE%E7%89%87%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AFhttp://www.baidu.com/img/logo.png%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E" >http://www.xxx.com/a.php?image=`http://www.baidu.com/img/logo.png`,右键新窗口打开图片，如果不是http://www.baidu.com/img/logo.png就可能存在SSRF漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>用dnslog等平台进行测试，看是否有IP把请求资源换成dnslog平台URL</li>
<li>burpsuite抓包，分析发送的请求是不是通过服务端发送的，因为SSRF要求是从服务端发起的请求，本地请求中不应该包含存在对资源的请求请求链接：<a class="link"   target="_blank" rel="noopener" href="http://www.xxx.com/a.php?image=%60http://www.baidu.com/img/logo.png%60%EF%BC%8C%E6%8A%93%E5%8C%85%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%8C%85%E4%B8%AD%E6%9C%89%60GET" >http://www.xxx.com/a.php?image=`http://www.baidu.com/img/logo.png`，抓包如果发现请求包中有`GET <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x2F;img&#x2F;logo.png HTTP&#x2F;1.1&#96;、Host:<a href="http://www.baidu.com……之类的字眼，就说明不是SSRF。">www.baidu.com……之类的字眼，就说明不是SSRF。</a></li>
</ol>
<p><strong>产生漏洞的常见函数</strong></p>
<ol>
<li><strong>file_get_contents</strong>：PHP中的file_get_contents函数用于从文件或URL中读取内容。如果应用程序接受用户输入的URL作为函数参数，并未对输入进行充分的验证和过滤，攻击者可以通过注入恶意URL来触发SSRF漏洞。</li>
<li>**sockopen()**：sockopen()是一个网络编程函数，通常用于在PHP中建立与远程服务器的网络连接。它的作用是打开一个网络套接字连接到指定的主机和端口。</li>
</ol>
<h3 id="3-常用绕过方法"><a href="#3-常用绕过方法" class="headerlink" title="3.常用绕过方法"></a>3.常用绕过方法</h3><ol>
<li><p><strong>限制为<code>http://www.xxx.com </code>域名时（利用@）</strong>：可以尝试采用http基本身份认证的方式绕过如：<code>http://www.aaa.com@www.bbb.com@www.ccc.com</code>，在对@解析域名中，不同的处理函数存在处理差异在PHP的parse_url中会识别<a class="link"   target="_blank" rel="noopener" href="http://www.ccc.com,而libcurl则识别为www.bbb.com/" >www.ccc.com，而libcurl则识别为www.bbb.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><strong>采用短网址绕过</strong>：短网址绕过的原理是基于短网址服务的重定向机制。一般来说，短网址服务会将用户提供的长网址映射到一个较短的别名，并将该别名与原始的长网址进行关联。即将目标地址改为我们选择的短网址，如：<code>https://example.com/show-image?url=https://goo.gl/abc123</code>。</p>
</li>
<li><p><strong>采用进制转换</strong>：运用网上的地址进制转换器将地址转换之后也可以访问，如：127.0.0.1转换为十进制为：2130706433；转换为十六进制为：7F000001</p>
</li>
<li><p><strong>利用特殊域名</strong>：利用特殊域名的原理是指攻击者通过使用某些特殊的域名或 IP 地址来绕过目标服务器对目标地址的验证和过滤。这些特殊的域名或 IP 地址可以是指向内部网络、本地主机或其他受限资源的地址。</p>
<p>下面是一些常见的特殊域名：</p>
<ul>
<li><p><code>localhost</code>和<code>1.7.0.0.1</code>：指向本地主机，一般用于指定目标地址为本地服务。例如，<code>http://localhost:8080</code>。</p>
</li>
<li><p>内部网：</p>
<p><code>10.0.0.0</code> - <code>10.255.255.255</code>：用于私有网络。</p>
<p><code>172.16.0.0</code> - <code>172.31.255.255</code>：用于私有网络。</p>
<p><code>192.168.0.0</code> - <code>192.168.255.255</code>：用于私有网络。</p>
</li>
<li><p><code>169.254.x.x</code>：这是保留的自动配置IPv4地址，用于本地链路本地连接。虽然通常用于DHCP配置失败的自动配置，但攻击者可能会利用它来访问内部资源</p>
</li>
<li><p>内部域名：这些域名通常用于内部网络和本地开发环境，如：</p>
<p><code>intranet.example.com</code></p>
<p><code>internal.example.com</code></p>
<p><code>dev.local</code></p>
</li>
</ul>
</li>
<li><p>**利用<code>[::]</code>**：该符号与127.0.0.1等效，可以利用他来绕过127.0.0.1或localhost</p>
</li>
<li><p><strong>利用句号</strong>：将地址中用来隔开的点换位句号，在部分情况同样可以使用。</p>
</li>
<li><p><strong>CRLF 编码绕过</strong></p>
<blockquote>
<p>%0d-&gt;0x0d-&gt;\r回车<br>%0a-&gt;0x0a-&gt;\n换行<br>进行HTTP头部注入</p>
</blockquote>
</li>
<li><p>利用封闭的字母数字</p>
<p>利用Enclosed alphanumerics<br>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com<br><a href="http://169.254.169.254>>>http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]">http://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]</a><br>List:<br>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳<br>⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇<br>⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛<br>⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵<br>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ<br>⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴<br>⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</p>
</li>
</ol>
<h2 id="三-漏洞的利用"><a href="#三-漏洞的利用" class="headerlink" title="三.漏洞的利用"></a>三.漏洞的利用</h2><ol>
<li><p>内网访问</p>
<p>用HTTP协议来对内网的web进行访问，如：?url&#x3D;<a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1/flag.php" >http://127.0.0.1/flag.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>伪协议读取文件</p>
<p>这里的伪协议包括php伪协议和PHP支持的伪协议常见的如下</p>
<pre class="line-numbers language-none"><code class="language-none">file:&#x2F;&#x2F; — 访问本地文件系统
http:&#x2F;&#x2F; — 访问 HTTP(s) 网址
ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs
php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）
zlib:&#x2F;&#x2F; — 压缩流
data:&#x2F;&#x2F; — 数据（RFC 2397）
glob:&#x2F;&#x2F; — 查找匹配的文件路径模式
phar:&#x2F;&#x2F; — PHP 归档
ssh2:&#x2F;&#x2F; — Secure Shell 2
rar:&#x2F;&#x2F; — RAR
ogg:&#x2F;&#x2F; — 音频流
expect:&#x2F;&#x2F; — 处理交互式的流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>端口扫描</p>
<p>在SSRF中，dict协议与http协议可以用来探测内网主机存活与端口开放情况。</p>
<pre class="line-numbers language-none"><code class="language-none">?url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:8000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>用burp，在intruder中，将端口设置为变量。使用Simple List扫描常用端口，或者使用NumerList进行枚举。当发现长度不同的数据包时，再用<code>http</code>协议进一步探测。</p>
<pre class="line-numbers language-none"><code class="language-none">?url&#x3D;http:&#x2F;&#x2F;127.0.0.1:8111<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>发送POST请求</p>
<p>若要发送POST请求，则需要Gopher协议的利用，协议的用法在上边已经说明，但要注意的一点是：在get传参中，构造<code>HTTP</code>数据包，<code>URL</code>编码、替换回车换行为<code>%0d%0a</code>，<code>HTTP</code>包最后加<code>%0d%0a</code>代表消息结束，发送<code>gopher</code>协议, 协议后的<code>IP</code>一定要接端口。</p>
<p>在post传参当中：<code>POST</code>与<code>GET</code>传参的区别：它有<code>4</code>个参数为必要参数，需要传递<code>Content-Type</code>,<code>Content-Length</code>,<code>host</code>,<code>post</code>的参数</p>
</li>
<li><p>提交文件</p>
<p>先正常抓取一个文件上传的包，再将其改为gopher协议的格式，便可以传输文件了。</p>
</li>
</ol>
<p>下面讲的这两个协议的利用是重点。</p>
<h4 id="攻击FastCGI协议"><a href="#攻击FastCGI协议" class="headerlink" title="攻击FastCGI协议"></a>攻击FastCGI协议</h4><p>首先我们要说明，什么是FastCGI协议？<br>该协议是改进web服务器与应用程序之间的通讯协议，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。record头固定有八个，其有如下格式：</p>
   <pre class="line-numbers language-none"><code class="language-none">typedef struct &#123;
  &#x2F;* Header *&#x2F;
  unsigned char version; &#x2F;&#x2F; 版本
  unsigned char type; &#x2F;&#x2F; 本次record的类型
  unsigned char requestIdB1; &#x2F;&#x2F; 本次record对应的请求id
  unsigned char requestIdB0;
  unsigned char contentLengthB1; &#x2F;&#x2F; body体的大小
  unsigned char contentLengthB0;
  unsigned char paddingLength; &#x2F;&#x2F; 额外块大小
  unsigned char reserved; 
 
  &#x2F;* Body *&#x2F;
  unsigned char contentData[contentLength];
  unsigned char paddingData[paddingLength];
&#125; FCGI_Record;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>PHP—FPM</strong></p>
<p>FastCGI的进程管理工具，即FastCGI的具体实现，在其中的进程中，包含了master和worker进程，其中master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，worker 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。简单来说的话就是解析器，流程如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF%EF%BC%89%E6%BC%8F%E6%B4%9E/fastCGI.png"
                     
                ></p>
<p>假设用户访问<a class="link"   target="_blank" rel="noopener" href="http://127.0.0.1/index.php?a=1&b=2%EF%BC%8C%E5%A6%82%E6%9E%9Cweb%E7%9B%AE%E5%BD%95%E6%98%AF/var/www/html%EF%BC%8C%E9%82%A3%E4%B9%88Nginx%E4%BC%9A%E5%B0%86%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%8F%98%E6%88%90%E5%A6%82%E4%B8%8Bkey-value%E5%AF%B9%EF%BC%9A" >http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对： <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;,
    &#39;REQUEST_METHOD&#39;: &#39;GET&#39;,
    &#39;SCRIPT_FILENAME&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&#39;,
    &#39;SCRIPT_NAME&#39;: &#39;&#x2F;index.php&#39;,
    &#39;QUERY_STRING&#39;: &#39;?a&#x3D;1&amp;b&#x3D;2&#39;,
    &#39;REQUEST_URI&#39;: &#39;&#x2F;index.php?a&#x3D;1&amp;b&#x3D;2&#39;,
    &#39;DOCUMENT_ROOT&#39;: &#39;&#x2F;var&#x2F;www&#x2F;html&#39;,
    &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;,
    &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;,
    &#39;REMOTE_PORT&#39;: &#39;12345&#39;,
    &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;,
    &#39;SERVER_PORT&#39;: &#39;80&#39;,
    &#39;SERVER_NAME&#39;: &quot;localhost&quot;,
    &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>攻击原理</strong></p>
<p>PHP-FPM默认监听的端口是9000，一般情况会只会接受127.0.0.1的请求，但假设这个端口可以在公网中访问到，我们便可以借用此协议对内网进行访问，这里就就牵扯到了FPM接收数据包中的一个值了：SCRIPT_FILENAME，这个值指向的就是要执行的文件，只要我们自己构造这个值，就可以执行任意PHP文件。并且，我们只能执行服务器上现有的PHP文件。故这里建议在生成攻击url时用kali上的Gopherus工具生成比较简单</p>
<p>该协议用法具体见：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/mysteryflower/article/details/94386461" >Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写_mysteryflower的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="攻击Redis协议"><a href="#攻击Redis协议" class="headerlink" title="攻击Redis协议"></a>攻击Redis协议</h4><p><strong>简介</strong></p>
<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string、list、set、zset和hash。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p><strong>常用命令</strong></p>
<pre class="line-numbers language-none"><code class="language-none">set xz &quot;Hacker&quot;                     # 设置键xz的值为字符串Hacker
get xz                              # 获取键xz的内容
SET score 857                       # 设置键score的值为857
      INCR score                          # 使用INCR命令将score的值增加1
      GET score                           # 获取键score的内容
      keys *                              # 列出当前数据库中所有的键
      config set protected-mode no        # 关闭安全模式
      get anotherkey                      # 获取一个不存在的键的值
      config set dir &#x2F;root&#x2F;redis          # 设置保存目录
      config set dbfilename redis.rdb     # 设置保存文件名
      config get dir                      # 查看保存目录
      config get dbfilename               # 查看保存文件名
      save                                # 进行一次备份操作
      flushall                            # 删除所有数据
      del key                             # 删除键为key的数据
      slaveof ip port                 # 设置主从关系
      redis-cli -h ip -p 6379 -a passwd   # 外部连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>基本操作</strong></p>
<p>1.使用SET和GET命令，可以完成基本的赋值和取值操作； </p>
<p>2.Redis是不区分命令的大小写的，set和SET是同一个意思； </p>
<p>3.使用keys *可以列出当前数据库中的所有键；</p>
<p>4.当尝试获取一个不存在的键的值时，Redis会返回空，即(nil)； </p>
<p>5.如果键的值中有空格，需要使用双引号括起来，如”Hello World”；</p>
<p><strong>各参数含义</strong></p>
<p>port参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为port后面接端口号，如port 6379，表示Redis服务器将在6379端口上进行监听来等待客户端的连接。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>bind参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如bind 192.168.1.100 10.0.0.1，表允许192.168.1.100和10.0.0.1两个IP连接。如果设置为0.0.0.0则表示任意ip都可连接，说白了就是白名单。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>save参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个save参数，如：
save 900 1
save 300 10
save 60 10000
表示如果数据库的内容在60秒后产生了10000次改变，或者300秒后产生了10次改变，或者900秒后产生了1次改变，那么立即进行备份操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>requirepass参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>dir参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为dir后接指定的路径，默认为dir .&#x2F;，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>dbfilename参数</p>
<pre class="line-numbers language-none"><code class="language-none">格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename dump.rdb，即备份文件的名字为dump.rdb。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>config命令</p>
<pre class="line-numbers language-none"><code class="language-none">通过config命令可以读取和设置dir参数以及dbfilename参数，因为这条命令比较危险（实验将进行详细介绍），所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command CONFIG HTCMD，可以将CONFIG命令重命名为HTCMD。配置文件默认是没有对CONFIG命令进行重命名操作的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>protected-mode参数</p>
<pre class="line-numbers language-none"><code class="language-none">redis3.2之后添加了protected-mode安全模式，默认值为yes，开启后禁止外部连接，所以在测试时，先在配置中修改为no。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>攻击方式主要是利用redis协议的未授权访问。</p>
<p> 全部用法详情见详细解释见：<a class="link"   target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/265646.html" >SSRF的利用方式 - FreeBuf网络安全行业门户 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 服务器端请求伪造漏洞</li>
        <li><strong>Author:</strong> 阿巴</li>
        <li><strong>Created at:</strong> 2023-07-16 14:35:17</li>
        
            <li>
                <strong>Updated at:</strong> 2023-08-02 20:42:25
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2023/07/16/服务器请求伪造（SSRF）漏洞/
        </li>
        <li>
            <strong>License:</strong> This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/web%E5%AE%89%E5%85%A8/">#web安全</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/07/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%AC%94%E8%AE%B0/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">文件上传笔记</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/07/16/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89%E6%94%BB%E5%87%BB/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">跨站脚本攻击（XSS）攻击</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">服务器端请求伪造漏洞</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E"><span class="nav-text">服务器端请求伪造漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D"><span class="nav-text">一.漏洞介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB"><span class="nav-text">二.漏洞分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89"><span class="nav-text">1.跨站请求伪造（CSRF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-SSRF"><span class="nav-text">2.服务器端请求伪造(SSRF)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">3.常用绕过方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8"><span class="nav-text">三.漏洞的利用</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>Invalid date</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">阿巴</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br>
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.2</a>
        </div>
        
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>





    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>







<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
